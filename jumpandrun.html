<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Infinite Funny Jump & Run — Boost & Enemies</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;background:#05070b;color:#ddd;font-family:system-ui,monospace;overflow:hidden}
  canvas{display:block}
  #ui{position:fixed;left:12px;top:12px;font-size:14px;pointer-events:none}
  .row{background:rgba(0,0,0,.45);padding:6px 10px;border-radius:8px;margin-bottom:6px}
  #death{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.9)}
  #death .box{background:#101216;padding:22px;border-radius:12px;text-align:center}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
  <div class="row">
    Distance: <span id="score">0</span> |
    Highscore: <span id="high">0</span>
  </div>
  <div class="row">
    Boost: <span id="boost">READY</span> |
    Controls: ← → move, ↑/Space jump, <b>B</b> boost, <b>S</b> shoot, <b>R</b> restart
  </div>
  <div class="row" id="msg">Guaranteed doable. Enemies are dumb.</div>
</div>

<div id="death">
  <div class="box">
    <div id="deathText"></div>
    <div id="deathSub" style="margin-top:8px"></div>
  </div>
</div>

<script>
/* =====================================================
   Single-file infinite jump & run
   - Guaranteed doable generation
   - Boost flight every 10s for 2s (B)
   - Enemies (shoot with S)
   - R always restarts
===================================================== */

/* ---------- Canvas ---------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){canvas.width=innerWidth;canvas.height=innerHeight}
addEventListener("resize",resize);resize();

/* ---------- Storage ---------- */
const STORE="funny_jump_high";
let highscore=Number(localStorage.getItem(STORE)||0);
document.getElementById("high").textContent=highscore;

/* ---------- Input ---------- */
const keys={};
addEventListener("keydown",e=>{
  keys[e.code]=true;
  if(e.code==="KeyR") restart();
});
addEventListener("keyup",e=>keys[e.code]=false);

/* ---------- Player ---------- */
const player={
  x:120,y:0,w:32,h:44,
  vx:0,vy:0,onGround:false,
  accel:1.2,jump:15,
  boosting:false
};

/* ---------- Physics ---------- */
const GRAV=0.9,FRICTION=0.85;

/* ---------- World ---------- */
let platforms=[],spikes=[],enemies=[],bullets=[];
let speed=4,dist=0,tick=0,dead=false;

/* ---------- Boost system ---------- */
const BOOST_COOLDOWN=10000;
const BOOST_DURATION=2000;
let boostReady=true;
let boostUntil=0;
let nextBoostTime=0;

/* ---------- Generation ---------- */
function spawnStart(){
  platforms=[];spikes=[];enemies=[];bullets=[];
  platforms.push({x:-400,y:canvas.height-140,w:800,h:18});
  let x=200,y=canvas.height-140;
  for(let i=0;i<7;i++){
    const w=r(90,220);
    platforms.push({x,y:y-r(-20,40),w,h:18});
    x+=w+r(140,260);
  }
}

function spawnNext(){
  const last=platforms[platforms.length-1];
  const gap=r(140,320);
  let y=last.y+r(-120,160);
  y=clamp(y,80,canvas.height-90);
  const w=r(90,220);
  const x=last.x+last.w+gap;
  platforms.push({x,y,w,h:18});

  if(Math.random()<0.25)
    enemies.push({x:x+r(40,120),y:y-32,w:28,h:28,vx:-1});

  if(Math.random()<0.25)
    spikes.push({x:x-r(40,120),y:canvas.height-44,w:30,h:30});
}

/* ---------- Restart ---------- */
function restart(){
  dead=false;
  dist=0;speed=4;tick=0;
  player.x=120;player.y=canvas.height-220;
  player.vx=player.vy=0;
  boostReady=true;player.boosting=false;
  nextBoostTime=performance.now()+BOOST_COOLDOWN;
  document.getElementById("boost").textContent="READY";
  document.getElementById("death").style.display="none";
  spawnStart();
}
restart();

/* ---------- Update ---------- */
function update(){
  if(dead) return;
  tick++;dist+=speed;
  if(tick%600===0) speed=Math.min(10,speed+0.3);

  /* movement */
  if(keys["ArrowLeft"]) player.vx-=player.accel;
  if(keys["ArrowRight"]) player.vx+=player.accel;

  if((keys["Space"]||keys["ArrowUp"])&&player.onGround){
    player.vy=-player.jump;
    player.onGround=false;
  }

  /* boost */
  const now=performance.now();
  if(keys["KeyB"]&&boostReady){
    boostReady=false;
    player.boosting=true;
    boostUntil=now+BOOST_DURATION;
    nextBoostTime=now+BOOST_COOLDOWN;
    document.getElementById("boost").textContent="BOOSTING";
  }
  if(player.boosting){
    player.vy=-3; // guaranteed upward thrust
    if(now>boostUntil){
      player.boosting=false;
      document.getElementById("boost").textContent="COOLDOWN";
    }
  } else if(!boostReady && now>nextBoostTime){
    boostReady=true;
    document.getElementById("boost").textContent="READY";
  }

  /* shoot */
  if(keys["KeyS"]){
    if(!keys._shot){
      bullets.push({x:player.x+player.w,y:player.y+player.h/2,vx:10});
      keys._shot=true;
    }
  } else keys._shot=false;

  /* physics */
  if(!player.boosting) player.vy+=GRAV;
  player.x+=player.vx;player.y+=player.vy;
  player.vx*=FRICTION;

  /* scroll */
  [...platforms,...spikes,...enemies,...bullets].forEach(o=>o.x-=speed);

  /* collisions */
  player.onGround=false;
  for(const p of platforms){
    if(player.vy>=0 &&
      player.x+player.w>p.x && player.x<p.x+p.w &&
      player.y+player.h<=p.y+20 &&
      player.y+player.h+player.vy>=p.y){
        player.y=p.y-player.h;
        player.vy=0;
        player.onGround=true;
    }
  }

  for(const s of spikes) if(hit(player,s)) die("SPIKES WIN");
  for(const e of enemies) if(hit(player,e)) die("ENEMY BONK");

  /* bullets vs enemies */
  bullets.forEach(b=>{
    enemies.forEach(e=>{
      if(hit(b,e)){
        e.dead=true;b.dead=true;
      }
    });
  });

  enemies=enemies.filter(e=>!e.dead&&e.x>-100);
  bullets=bullets.filter(b=>!b.dead&&b.x<canvas.width+100);

  /* fall */
  if(player.y>canvas.height+100) die("YOU FELL");

  /* spawn */
  platforms=platforms.filter(p=>p.x+p.w>-200);
  while(platforms.length<9||platforms.at(-1).x<canvas.width+300)
    spawnNext();

  /* UI */
  document.getElementById("score").textContent=Math.floor(dist);
}

/* ---------- Death ---------- */
function die(reason){
  dead=true;
  const d=Math.floor(dist);
  if(d>highscore){
    highscore=d;
    localStorage.setItem(STORE,highscore);
    document.getElementById("high").textContent=highscore;
  }
  document.getElementById("deathText").textContent=reason;
  document.getElementById("deathSub").textContent=`Distance ${d} | Highscore ${highscore}`;
  document.getElementById("death").style.display="flex";
  setTimeout(restart,1000); // auto-restart
}

/* ---------- Draw ---------- */
function draw(){
  ctx.fillStyle="#070a12";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#333";
  platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h));

  ctx.fillStyle="red";
  spikes.forEach(s=>{
    ctx.beginPath();
    ctx.moveTo(s.x,s.y+s.h);
    ctx.lineTo(s.x+s.w/2,s.y);
    ctx.lineTo(s.x+s.w,s.y+s.h);
    ctx.fill();
  });

  ctx.fillStyle="#ff0";
  enemies.forEach(e=>ctx.fillRect(e.x,e.y,e.w,e.h));

  ctx.fillStyle="#0ff";
  bullets.forEach(b=>ctx.fillRect(b.x,b.y,8,3));

  ctx.fillStyle=player.boosting?"#0ff":"#0f0";
  ctx.fillRect(player.x,player.y,player.w,player.h);
}

/* ---------- Helpers ---------- */
function hit(a,b){
  return a.x<b.x+b.w&&a.x+(a.w||8)>b.x&&a.y<b.y+b.h&&a.y+(a.h||3)>b.y;
}
function r(a,b){return Math.random()*(b-a)+a}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

/* ---------- Loop ---------- */
function loop(){update();draw();requestAnimationFrame(loop)}
loop();
</script>
</body>
</html>
