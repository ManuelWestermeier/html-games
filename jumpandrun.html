<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Beautiful Infinite Jump & Run — Working Combat (WASD + Touch)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
html,body{
  margin:0;height:100%;overflow:hidden;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background:#06080f;color:#eef
}
canvas{display:block}

/* Glass HUD */
#ui{
  position:fixed;left:16px;top:16px;
  backdrop-filter:blur(14px);
  background:rgba(20,25,40,.55);
  border-radius:14px;
  padding:14px 18px;
  box-shadow:0 20px 40px rgba(0,0,0,.4);
  font-size:14px
}
.row{margin-bottom:6px}
.label{opacity:.7}

/* Death overlay */
#death{
  position:fixed;inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:radial-gradient(circle at center,rgba(0,0,0,.6),rgba(0,0,0,.95))
}
#death .box{
  background:linear-gradient(145deg,#14192a,#0a0e1c);
  border-radius:20px;
  padding:28px 36px;
  box-shadow:0 30px 80px rgba(0,0,0,.7);
  text-align:center
}
#death h1{margin:0 0 10px;font-size:28px}
#death p{margin:4px 0;opacity:.8}

/* small touch hint at bottom for mobile */
#touchHint{
  position:fixed;left:50%;transform:translateX(-50%);bottom:18px;
  background:rgba(255,255,255,0.02);padding:8px 12px;border-radius:12px;font-size:12px;color:#cfe;
  backdrop-filter:blur(6px)
}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
  <div class="row">
    <span class="label">Distance</span>
    <b id="score">0</b>
    &nbsp;|&nbsp;
    <span class="label">High</span>
    <b id="high">0</b>
  </div>
  <div class="row">
    <span class="label">Boost</span>
    <b id="boost">READY</b>
  </div>
  <div class="row label">
    ← → / A D move · ↑ / W jump · S shoot · Tap enemies to kill/jump · Swipe to move
  </div>
</div>

<div id="death">
  <div class="box">
    <h1 id="deathText"></h1>
    <p id="deathSub"></p>
    <p class="label">Restarting…</p>
  </div>
</div>

<div id="touchHint">Tippe Gegner zum töten oder springen · W/A/S/D oder Pfeile · Swipe bewegt</div>

<script>
/* Full single-file game with added:
   - WASD controls (A/D = left/right, W = jump, S = shoot)
   - Pointer/touch support: swipe to move, tap to kill/bounce on enemy
   - Click (mouse) on enemies to kill and bounce
*/

/* ====== Canvas / DOM refs ====== */
const c = document.getElementById('c'), ctx = c.getContext('2d');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const boostEl = document.getElementById('boost');
const deathEl = document.getElementById('death');
const deathText = document.getElementById('deathText');
const deathSub = document.getElementById('deathSub');

function resize(){ c.width = innerWidth; c.height = innerHeight; }
addEventListener('resize', resize);
resize();

/* ====== Storage ====== */
const STORE = 'beautiful_jump_high_v2';
let high = +localStorage.getItem(STORE) || 0;
highEl.textContent = high;

/* ====== Input ====== */
const keys = {};
addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'KeyR') restart();
});
addEventListener('keyup', e => keys[e.code] = false);

// Pointer/touch handling
let activePointer = null;
let pointerStart = null;
let pointerMoved = false;
const SWIPE_DEADZONE = 18; // px
const TAP_TIME = 300; // ms
const TAP_MOVE_THRESHOLD = 12; // px

addEventListener('pointerdown', e => {
  // only handle primary pointer
  if (activePointer !== null) return;
  activePointer = e.pointerId;
  pointerStart = { x: e.clientX, y: e.clientY, t: performance.now() };
  pointerMoved = false;
  // capture so we continue to get move/up
  try { (e.target).setPointerCapture(activePointer); } catch (err) {}
  // immediate directional set on pointerdown for quick swipes
  updatePointerMovement(e.clientX, e.clientY);
});

addEventListener('pointermove', e => {
  if (activePointer !== e.pointerId) return;
  pointerMoved = pointerMoved || (Math.hypot(e.clientX - pointerStart.x, e.clientY - pointerStart.y) > TAP_MOVE_THRESHOLD);
  updatePointerMovement(e.clientX, e.clientY);
});

addEventListener('pointerup', e => {
  if (activePointer !== e.pointerId) return;
  const duration = performance.now() - pointerStart.t;
  const dx = e.clientX - pointerStart.x, dy = e.clientY - pointerStart.y;
  // Tap detection
  if (duration < TAP_TIME && Math.hypot(dx, dy) < TAP_MOVE_THRESHOLD) {
    handleTap(e.clientX, e.clientY);
  } else {
    // swipe up detection (end)
    if (dy < -SWIPE_DEADZONE) {
      // jump on swipe-up
      if (player.on) { player.vy = -player.jump; player.on = false; }
    }
  }
  // clear movement keys set by pointer
  keys['ArrowLeft'] = keys['ArrowRight'] = keys['KeyA'] = keys['KeyD'] = false;
  activePointer = null;
  pointerStart = null;
  pointerMoved = false;
  try { (e.target).releasePointerCapture(e.pointerId); } catch (err) {}
});

addEventListener('pointercancel', e => {
  if (activePointer !== e.pointerId) return;
  keys['ArrowLeft'] = keys['ArrowRight'] = keys['KeyA'] = keys['KeyD'] = false;
  activePointer = null; pointerStart = null; pointerMoved = false;
});

function updatePointerMovement(px, py){
  if (!pointerStart) return;
  const dx = px - pointerStart.x, dy = py - pointerStart.y;
  // horizontal swipe/drag => move while dragging left/right
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_DEADZONE) {
    if (dx < 0) {
      keys['ArrowLeft'] = true; keys['KeyA'] = true;
      keys['ArrowRight'] = false; keys['KeyD'] = false;
    } else {
      keys['ArrowRight'] = true; keys['KeyD'] = true;
      keys['ArrowLeft'] = false; keys['KeyA'] = false;
    }
  } else {
    // if vertical dominant, don't force horizontal keys
    keys['ArrowLeft'] = keys['ArrowRight'] = keys['KeyA'] = keys['KeyD'] = false;
  }
}

/* ====== Player ====== */
const player = {
  x: 140, y: 0, w: 34, h: 46,
  vx: 0, vy: 0, on: false,
  jump: 15, acc: 1.2,
  boosting: false,
  health: 1
};
const GRAV = 0.9, FRICTION = 0.85;

/* ====== World state ====== */
let plats = [], spikes = [], enemies = [], bullets = [], particles = [];
let speed = 4, dist = 0, dead = false, tick = 0;

/* ====== Boost system ====== */
const BOOST_CD = 10000, BOOST_DUR = 2000;
let boostReady = true, boostUntil = 0, nextBoost = 0;

/* ====== Shooting ====== */
let lastShot = 0;
const SHOT_CD = 180; // ms between shots

/* ====== Init / Restart ====== */
function restart(){
  dead = false;
  dist = 0;
  speed = 4;
  tick = 0;
  player.x = 140;
  player.y = c.height - 220;
  player.vx = 0;
  player.vy = 0;
  player.boosting = false;
  player.health = 1;

  plats = []; spikes = []; enemies = []; bullets = []; particles = [];
  plats.push({ x: -400, y: c.height - 140, w: 900, h: 18 });
  let curX = 200, curY = c.height - 140;
  for (let i=0;i<7;i++){
    const w = rndInt(100,220);
    plats.push({ x: curX, y: curY - rndInt(-20,40), w, h:18 });
    curX += w + rndInt(140,260);
    curY = clamp(plats.at(-1).y, 80, c.height - 80);
  }

  boostReady = true; player.boosting = false;
  boostEl.textContent = 'READY';
  deathEl.style.display = 'none';
}
restart();

/* ====== Update loop ====== */
function update(){
  if (dead) return;
  tick++; dist += speed;
  if (tick % 600 === 0) speed = Math.min(10, speed + 0.3);

  // horizontal input (arrow keys OR WASD)
  if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= player.acc;
  if (keys['ArrowRight'] || keys['KeyD']) player.vx += player.acc;

  // jump (Space, ArrowUp, W)
  if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.on){
    player.vy = -player.jump;
    player.on = false;
  }

  // boost
  const now = performance.now();
  if (keys['KeyB'] && boostReady){
    boostReady = false;
    player.boosting = true;
    boostUntil = now + BOOST_DUR;
    nextBoost = now + BOOST_CD;
    boostEl.textContent = 'BOOSTING';
  }
  if (player.boosting){
    player.vy = -3.6;
    if (keys['ArrowRight'] || keys['KeyD']) player.vx += 0.6;
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= 0.6;
    if (now > boostUntil){
      player.boosting = false;
      boostEl.textContent = 'COOLDOWN';
    }
  } else if (!boostReady && now > nextBoost){
    boostReady = true;
    boostEl.textContent = 'READY';
  }

  // shooting (S): rate-limited. Note: KeyS also used for "tap" on touch; here it's keyboard shoot.
  if (keys['KeyS'] && now - lastShot > SHOT_CD){
    bullets.push({
      x: player.x + player.w,
      y: player.y + player.h * 0.45,
      vx: 12,
      owner: 'player',
      w: 10, h: 4
    });
    lastShot = now;
  }

  // physics
  if (!player.boosting) player.vy += GRAV;
  player.x += player.vx;
  player.y += player.vy;
  player.vx *= FRICTION;

  // world scroll: move platforms, spikes, enemies and bullets relative to world
  for (const o of [...plats, ...spikes, ...enemies, ...bullets, ...particles]) {
    o.x -= speed;
  }

  // additionally move bullets by their own vx
  for (const b of bullets) b.x += b.vx;

  // simple enemy behavior: bob and sometimes shoot toward player
  for (const e of enemies){
    e.timer = (e.timer || 0) + 1;
    e.oy = e.oy || e.y;
    e.y = e.oy + Math.sin((tick + (e.id||0)*57) * 0.04) * 8;
    e.shootTimer = e.shootTimer || 0;
    if (e.x < c.width + 100 && e.x > -50){
      e.shootTimer--;
      if (e.shootTimer <= 0){
        bullets.push({
          x: e.x,
          y: e.y + e.h/2,
          vx: -6,
          owner: 'enemy',
          w: 8, h: 4
        });
        e.shootTimer = rndInt(60, 180);
      }
    }
  }

  // collisions: player <-> platforms
  player.on = false;
  for (const pl of plats){
    if (player.vy >= 0 &&
        player.x + player.w > pl.x &&
        player.x < pl.x + pl.w &&
        player.y + player.h <= pl.y + 18 &&
        player.y + player.h + player.vy >= pl.y){
      player.y = pl.y - player.h;
      player.vy = 0;
      player.on = true;
    }
  }

  // collisions: player with spikes or enemy bullets or enemies
  for (const s of spikes){
    if (rectHit(player, s)) {
      die('SPIKES');
      break;
    }
  }
  if (dead) return;

  for (const e of enemies){
    if (!e.dead && rectHit(player, e)) {
      // if player is falling onto the enemy (vertical collision from above), bounce and kill enemy
      if (player.vy > 0 && (player.y + player.h - player.vy) <= e.y + 6) {
        killEnemy(e, true);
        player.vy = -player.jump * 0.6; // bounce up
        player.on = false;
      } else {
        die('ENEMY BONK');
        break;
      }
    }
  }
  if (dead) return;

  for (const b of bullets){
    if (b.owner === 'enemy' && rectHit(player, b)){
      die('SHOT BY ENEMY');
      break;
    }
  }
  if (dead) return;

  // bullets vs enemies: player bullets kill enemies
  for (const b of bullets){
    if (b.owner === 'player'){
      for (const e of enemies){
        if (!e.dead && rectHit(b, e)){
          killEnemy(e, false);
          b.dead = true;
          break;
        }
      }
    }
  }

  // cleanup: remove dead bullets/enemies offscreen
  bullets = bullets.filter(b => !b.dead && b.x < c.width + 200 && b.x > -400);
  enemies = enemies.filter(e => {
    if (e.dead){
      e.dieTimer--;
      return e.dieTimer > 0;
    }
    return e.x + e.w > -200;
  });

  // fall out
  if (player.y > c.height + 120) die('FALL');

  // spawn ahead
  plats = plats.filter(pl => pl.x + pl.w > -200);
  spikes = spikes.filter(s => s.x + s.w > -200);
  while (plats.length < 9 || plats.at(-1).x < c.width + 300){
    spawnNext();
  }

  // update particles
  for (const p of particles){
    p.x += p.vx; p.y += p.vy; p.life--;
    p.vx *= 0.98; p.vy += 0.18;
  }
  particles = particles.filter(p => p.life > 0);

  // UI
  scoreEl.textContent = Math.floor(dist);
}

/* ====== Enemy kill helper ====== */
function killEnemy(e, bouncePlayer){
  if (!e || e.dead) return;
  e.dead = true;
  e.dieTimer = 30;
  spawnParticles(e.x + e.w/2, e.y + e.h/2, 14, '#ffd66b');
  // optional small reward or effect
  // bounce player lightly if bouncePlayer true or if tap killed
  if (bouncePlayer) {
    player.vy = -player.jump * 0.6;
    player.on = false;
  }
}

/* ====== Tap / Click handling ====== */
function handleTap(clientX, clientY){
  // convert to canvas coords (same here)
  const x = clientX, y = clientY;
  // find topmost enemy under the tap (iterate reverse)
  for (let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    if (!e.dead && x >= e.x && x <= e.x + e.w && y >= e.y && y <= e.y + e.h){
      // kill and bounce player upward
      killEnemy(e, true);
      return;
    }
  }
  // if not an enemy, consider shooting toward tapped location
  // spawn a bullet heading roughly right (same behavior as keyboard shoot)
  bullets.push({
    x: player.x + player.w,
    y: player.y + player.h * 0.45,
    vx: 12,
    owner: 'player',
    w: 10, h: 4
  });
  lastShot = performance.now();
}

/* ====== Spawn logic (guaranteed doable) ====== */
function spawnNext(){
  const last = plats.at(-1);
  const gap = rndInt(140, 320);
  let y = last.y + rndInt(-120, 160);
  y = clamp(y, 80, c.height - 90);
  const w = rndInt(90, 220);
  const x = last.x + last.w + gap;
  plats.push({ x, y, w, h: 18 });

  if (Math.random() < 0.28){
    spikes.push({ x: x - rndInt(40, Math.max(60, gap - 20)), y: c.height - 44, w: 30, h: 30 });
  }

  if (Math.random() < 0.32){
    const ex = x + rndInt(40, Math.max(40, w - 40));
    const ey = y - 30;
    enemies.push({
      x: ex,
      y: ey,
      w: 28,
      h: 28,
      id: Math.floor(Math.random() * 10000),
      shootTimer: rndInt(90, 220),
      dead: false
    });
  }
}

/* ====== Drawing ====== */
function draw(){
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,c.height);
  g.addColorStop(0, '#0c1530');
  g.addColorStop(1, '#02030a');
  ctx.fillStyle = g; ctx.fillRect(0,0,c.width,c.height);

  // subtle parallax lines
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  for (let i=0;i<60;i++){
    ctx.fillRect((tick*0.18 + i*200) % c.width, i * 30, 80, 2);
  }

  // draw platforms
  for (const pl of plats){
    ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 14;
    const pg = ctx.createLinearGradient(pl.x, pl.y, pl.x, pl.y + pl.h);
    pg.addColorStop(0, '#6a74ff'); pg.addColorStop(1, '#3a40d6');
    ctx.fillStyle = pg;
    roundRect(ctx, pl.x, pl.y, pl.w, pl.h, 8, true, false);
    ctx.shadowBlur = 0;
  }

  // spikes
  for (const s of spikes){
    ctx.fillStyle = '#ff4d4d';
    triangle(ctx, s.x, s.y, s.w, s.h);
    ctx.fillStyle = '#420';
    ctx.fillRect(s.x, s.y + s.h - 6, s.w, 6);
  }

  // enemies (alive or dying)
  for (const e of enemies){
    if (!e.dead){
      ctx.fillStyle = '#ffcc33';
      roundRect(ctx, e.x, e.y, e.w, e.h, 6, true, false);
      ctx.fillStyle = '#2b1b00';
      ctx.fillRect(e.x + 6, e.y + 8, 4, 6);
      ctx.fillRect(e.x + e.w - 10, e.y + 8, 4, 6);
    } else {
      const t = e.dieTimer / 30;
      ctx.globalAlpha = t;
      ctx.fillStyle = '#ffb93b';
      roundRect(ctx, e.x + (1-t)*8, e.y + (1-t)*6, e.w * t, e.h * t, 6, true, false);
      ctx.globalAlpha = 1;
    }
  }

  // bullets
  for (const b of bullets){
    if (b.owner === 'player'){
      ctx.fillStyle = '#66ffff';
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.globalAlpha = 0.15;
      ctx.fillRect(b.x - 6, b.y - 2, b.w + 12, b.h + 4);
      ctx.globalAlpha = 1;
    } else {
      ctx.fillStyle = '#ff8b8b';
      ctx.fillRect(b.x, b.y, b.w, b.h);
    }
  }

  // particles
  for (const p of particles){
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.size, p.size);
    ctx.globalAlpha = 1;
  }

  // player with face & boost aura
  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  if (player.boosting){
    ctx.fillStyle = 'rgba(102,255,255,0.08)';
    ctx.beginPath();
    ctx.ellipse(0, 6, player.w + 18, player.h + 26, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.fillStyle = player.boosting ? '#66ffff' : '#66ff99';
  roundRect(ctx, -player.w/2, -player.h/2, player.w, player.h, 8, true, false);
  ctx.fillStyle = '#000';
  ctx.fillRect(-6, -6, 4, 6);
  ctx.fillRect(4, -6, 4, 6);
  ctx.fillRect(-6, 8, 12, 3);
  ctx.restore();
}

/* ====== Death ====== */
function die(reason){
  if (dead) return;
  dead = true;
  const d = Math.floor(dist);
  if (d > high){
    high = d;
    localStorage.setItem(STORE, high);
    highEl.textContent = high;
  }
  deathText.textContent = reason;
  deathSub.textContent = `Distance ${d} · High ${high}`;
  deathEl.style.display = 'flex';
  setTimeout(()=>{ restart(); }, 900);
}

/* ====== Utilities ====== */
function rnd(min, max){ return Math.random() * (max - min) + min; }
function rndInt(min, max){ return Math.floor(rnd(min, max+1)); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rectHit(a,b){
  return a.x < b.x + b.w && a.x + (a.w||8) > b.x && a.y < b.y + b.h && a.y + (a.h||3) > b.y;
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if (typeof r === 'number') r = {tl:r,tr:r,br:r,bl:r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}
function triangle(ctx,x,y,w,h){
  ctx.beginPath();
  ctx.moveTo(x, y + h);
  ctx.lineTo(x + w/2, y);
  ctx.lineTo(x + w, y + h);
  ctx.closePath();
  ctx.fill();
}
function spawnParticles(x,y,count,color){
  for (let i=0;i<count;i++){
    particles.push({
      x: x + rnd(-6,6),
      y: y + rnd(-6,6),
      vx: rnd(-3,3),
      vy: rnd(-4,0),
      life: rndInt(18,36),
      maxLife: 36,
      color: color || '#ffd66b',
      size: rndInt(2,4)
    });
  }
}

/* ====== Mouse click fallback (desktop) ====== */
addEventListener('click', e => {
  handleTap(e.clientX, e.clientY);
});

/* ====== Main loop ====== */
function loop(){
  update();
  ctx.clearRect(0,0,c.width,c.height);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
